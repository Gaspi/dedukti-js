
// `type`
type : Type;
eta : type -> Type;

// `type` constructors
bool : type;
arrow : type -> type -> type;

// `ptype`
ptype : Type;
etap : ptype -> Type;

p : type -> ptype;
forallK : (type -> ptype) -> ptype;


eps : eta bool -> Type;

impl : eta bool -> eta bool -> eta bool;

forall : t:type -> (eta t -> eta bool) -> eta bool;

forallP : (type -> eta bool) -> eta bool;

: eta --> t => etap (p t);
: etap (p (arrow l r)) --> eta l -> eta r;
: etap (forallK f) --> x : type -> etap (f x);
: eps (forall t f) --> x:eta t -> eps (f x);
: eps (impl l r) --> eps l -> eps r;
: eps (forallP f) --> x:type -> eps (f x);

leibniz : etap (forallK (X:type => p (arrow X (arrow X bool)))) :=
    X:type  =>
    x:eta X =>
    y:eta X =>
    forall (arrow X bool) (P => impl (P x) (P y));

refl : eps (forallP (X => forall X (x:eta X => leibniz X x x))) :=
    X:type  =>
    x:eta X =>
    P:eta (arrow X bool) =>
    p:eps (P x) => p;

sym_leibniz : eps (forallP (X:type => forall X (x:eta X => forall X (y:eta X => impl (leibniz X x y) (leibniz X y x)))));
