// Dedukti is a logical framework based on the λΠ-calculus modulo
// in which many theories and logics can be expressed.
// Have a look at :
//   https://deducteam.github.io/
//   https://github.com/Deducteam/Dedukti

// Symbols are introduced together with their declared types using a colon `:`.
Nat  : Type;  // `Type` is a special "type of types"
zero : Nat;

// product types are built using `->`
succ : Nat -> Nat;
plus : Nat -> Nat -> Nat;


// Rewrite rules allow to define computation
zero_left_neutral : plus zero n --> n;
// Since `n` doesn't refer to a defined symbol, it is inferred to be a meta-variable
// The rule name `zero_left_neutral` is facultative and seldom useful

: plus n zero --> n;
: plus (succ n) m --> succ (plus n m);
: plus n (succ m) --> succ (plus n m);
// All rules must preserve types
// For instance the following rule is not accepted
//: plus --> zero;

// Symbols can be defined
one : Nat := succ zero;
//... which is equivalent to defining them with a rewrite rule
two : Nat;
: two --> succ one;

// `*` is a nameless meta-variable
mult : Nat -> Nat -> Nat;
: mult zero * --> zero;

// Function can be defined using lambda abstraction
twice : Nat -> Nat :=
  x:Nat => plus x x;

// The `#EVAL` command can be used to (fully) evaluate an expression
#EVAL Nat;
#EVAL (x:Nat => twice x)(one);

// The `#INFER` command can be used to infer the type of an expression
#INFER Nat -> Nat;
#INFER x : Nat => twice;

// The `#CHECK` command can be used to ensure an expression has a particular type
#CHECK |- zero : Nat;
#CHECK |- (Nat -> Nat) : Type;
#CHECK |- (x:Nat => twice x)(one) : Nat;

// The `#CHECK` command supports a local context of variables
#CHECK x : Nat, y : Nat -> Nat |- y x : Nat;

// The `#CHECK` also allows to check conversion
#CHECK x:Nat |- (x:Nat => plus x two) x == succ (succ x);



// Dependent product type allow to define lists parametrized by their size
Elt: Type;
Vector: Nat -> Type;
nil: Vector zero;
cons: n:Nat -> Elt -> Vector n -> Vector (succ n);

// Type checking handles higher order types
append: n:Nat -> Vector n -> m:Nat -> Vector m -> Vector (plus n m);
: append zero nil n v --> v;
: append (succ n) (cons n e v1) m v2 --> cons (plus n m) e (append n v1 m v2);




eq: Nat -> Nat -> Nat;
: eq n n --> one;




type: Type;
arrow: type -> type -> type;

term: type -> Type;

app: a:type -> b:type -> term (arrow a b) -> term a -> term b;
lambda: a:type -> b:type -> (term a -> term b) -> term (arrow a b);

: app a b (lambda a2 b2 (x => f[x])) arg --> f[arg];


