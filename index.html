<!DOCTYPE html>
<html lang="en">
<head>
  <title> Dedukti </title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="shortcut icon" type="image/png" href="ressources/favicon.png"/>
  
  <!-- Leaflet and Bootstrap: CSS style -->
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/fontawesome.min.css"> -->
  <link rel="stylesheet" href="ressources/fontawesome.min.css">
  
  <!-- <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous"> -->
  <link rel="stylesheet" href="ressources/bootstrap.min.css">

  <style> foo { background: black; } </style>
</head>
<body>


<div class="container">
  <button class="" onclick="process_all_instructions();">Type Check !</button>
  <div class="row align-items-start">
    <div class="col mx-3">
      <h1>Code</h1>
      <div class="form-outline mx-3">
<textarea class="form-control" id="code" rows="30">
#REQUIRE test;

// Declarations
A : Type;
a : A;
f : (x:A) -> A := x => x; 

// Rewrite rule
: x => X[a,A,x] --> X;

// Basic commands
#PRINT A;
#INFER x:A => A;
#EVAL (x=>x) (y=>y) (z=>A);
#CHECK A : Type;
</textarea>
      </div>
    </div>
    <div class="col mx-3">
      <h1>Ouput</h1>
      <div class="mx-3" id="logs"></div>
    </div>


  <!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script> -->
<script src="ressources/bootstrap.bundle.min.js"></script>
<script src="lib/term.js"></script>
<script src="lib/context.js"></script>
<script src="lib/env.js"></script>
<script src="moo/moo.js"></script>
<script src="lib/grammar.js"></script>
<script src="nearley/lib/nearley.js"></script>
<script>

// Logs handling
const logs = document.getElementById("logs");
function clear_logs() { logs.innerHTML = ""; }
function log_ok(title,msg)   { log(title,msg,['alert','alert-success']); }
function log_info(title,msg) { log(title,msg,['alert','alert-info']); }
function log_warn(title,msg) { log(title,msg,['alert','alert-warning']); }
function log_err(err)  {
  const msg = err.message || err;
  const i = msg && msg.indexOf(':');
  if (i >= 0) { log('ERROR: '+msg.slice(0,i), msg.slice(i+1), ['alert','alert-danger']); }
  else        { log('ERROR'                 , err           , ['alert','alert-danger']); }
}
function log(title,msg,classes=[]) {
  const div = document.createElement('div');
  div.style['white-space']= 'pre-wrap';
  div.innerHTML = '<strong>['+title+']</strong> '+msg;
  div.classList.add('p-1');
  div.classList.add('m-2');
  classes.forEach((x)=>div.classList.add(x));
  logs.appendChild(div);
}

// Create a Parser object from our grammar.
const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));
const initial_state = parser.save();

// Converts a string to a series of instructions
function parse(code) {
  parser.restore(initial_state);
  parser.feed(code);
  return parser.results[0];
}

// In place scoping of (meta-)term and instructions
function scope(e, env, ctx=Ctx()) {
  if (!e) { return e; }
  switch (e[c]) {
    // Variable, meta-variable or symbol to scope
    case "PreScope":
      const ind = index_of(ctx,e.name);
      if (ind != null) { return Var(ind, preferred_name=e.name); }
      const s = get(env,e.name);
      if (s) { return Ref(s.fullname); }
      return MVar(e.name,[])
    // (Meta-)term constructors
      break;
    case "PreRef": // Reference to check
      return Ref(do_get(env,e.name).fullname);
    case "All":
      e.dom = scope(e.dom, env, ctx);
      e.cod = scope(e.cod, env, extend(ctx, [e.name,null]));
      break;
    case "Lam":
      e.type = scope(e.type, env,ctx);
      e.body = scope(e.body, env, extend(ctx, [e.name,null]));
      break;
    case "App":
      e.func = scope(e.func, env,ctx);
      e.argm = scope(e.argm, env,ctx);
      break;
    case "MVar":
      for (let i = 0; i < e.args.length; i++) {
        e.args[i] = scope(e.args[i], env,ctx);
      }
      break;
    // Instruction constructors
    case "Check":
      e.type = scope(e.type, env,ctx);
    case "Eval":
    case "Infer":
    case "Print":
      e.term = scope(e.term, env,ctx);
      break;
    case "Def":
      e.def = scope(e.def, env,ctx);
    case "Decl":
      e.type = scope(e.type, env,ctx);
      break;
    case "Rew":
      e.lhs = scope(e.lhs, env,ctx);
      e.rhs = scope(e.rhs, env,ctx);
      break;
  }
  return e;
}

// Pretty prints a context
function show_context(ctx, i = 0) {
  const bind = get_bind(ctx, i);
  if (!bind) { return ""; }
  const term = " : " + (bind[1] ? show(nf(bind[1],{}), ctx) : "?");
  return show_context(ctx, i+1) + bind[0] + term + "\n";
}

// Converts a term to a string
function show(term, ctx = Ctx()) {
  switch (term[c]) {
    case "Knd": return "Kind";
    case "Typ": return "Type";
    case "Var": return get_name(ctx, term.index) || "#" + term.index;
    case "App":
      let text = ")";
      let vterm = term;
      while (vterm[c] === "App") {
        text = " " + show(vterm.argm, ctx) + text;
        vterm = vterm.func;
      }
      return "(" + show(vterm, ctx) + text;
    case "All":
      let dom = show(term.dom,ctx);
      let cod = show(term.cod,extend(ctx, [term.name, null]));
      return (term.name ? "("+term.name+" : "+dom+")" : dom) + " -> "+cod;
    case "Lam":
      let body = show(term.body, extend(ctx, [term.name, null]));
      return (term.type ? "("+term.name+" : "+show(term.type,ctx)+")" : term.name)+" => "+body;
    case "PreScope": return '?'+term.name;
    case "Ref": return term.name;
    case "Star": return '*';
    case "MVar": return term.name+"["+term.args.map((x)=>show(x,ctx)).join(',')+"]";
  }
}

// Shifts a term
function shift(term, inc=1, depth=0) {
  switch (term[c]) {
    case "Typ": return Typ();
    case "Star": return Star();
    case "Var":
      return Var(term.index < depth ? term.index : term.index + inc);
    case "Ref":
      return Ref(term.name);
    case "All":
      const dom = shift(term.dom,inc,depth+1);
      const cod = shift(term.cod,inc,depth  );
      return All(term.name,dom,cod);
    case "Lam":
      const type = term.type && shift(term.type, inc, depth  );
      const body =              shift(term.body, inc, depth+1);
      return Lam(term.name, type, body);
    case "App":
      return App(shift(term.func, inc, depth), shift(term.argm, inc, depth));
    case "MVar":
      return MVar(term.name,term.args.map((t)=>shift(t, inc, depth)));
    default:
      throw "Shift:\nUnexpected constructor:"+term[c];
  }
}

// Check that a and b have compatible head. Stacks conversion-relevant subterms in t.
function same_head(a,b,t) {
  if (a[c] !== b[c]) { return false; }
  switch (a[c]) {
    case "Var":
      if (a.index !== b.index) { return false; }
      break;
    case "Ref":
      if (a.name !== b.name) { return false; }
      break;
    case "All":
      t.push({a:a.dom,b:b.dom});
      t.push({a:a.cod,b:b.cod});
      break;
    case "Lam":
      t.push({a:a.body,b:b.body});
      break;
    case "App":
      t.push({a:a.func,b:b.func});
      t.push({a:a.argm,b:b.argm});
      break;
    case "MVar":
      if (a.name !== b.name || a.args.length !== b.args.length) { return false; }
      for (let i = 0; i < a.args.length; i++) {
        t.push({a:a.args[i],b:b.args[i]});
      }
      break;
    case "Typ":
    case "Knd":
    case "Star": break;
    default: throw "Equals:\nUnexpected constructor: "+term[c];
  }
  return true;
}

function equals(a, b) {
  let t = [ {a,b} ];
  while (t.length > 0) {
    const {a,b} = t.pop();
    if (a === b) { continue; }
    if (!same_head(a,b,t)) { return false; }
  }
  return true;
}

// Checks if two terms are equal
function are_convertible(a, b, env) {
  let t = [ {a,b} ];
  while (t.length > 0) {
    const {a,b} = t.pop();
    if (equals(a,b)) { continue; }
    if (!same_head( whnf(a,env) , whnf(b,env) ,t)) { return false; }
  }
  return true;
}

// Reduces a term until a normal form is found
function norm(term, env, rec) {
  function cont(t) { return rec(t,env,rec) };
  switch (term[c]) {
    case "Var": return Var(term.index);
    case "Typ":
    case "Knd":
    case "Star": return term;
    case "All": return All(term.name, cont(term.dom), cont(term.cod));
    case "Lam": return Lam(term.name, term.type && cont(term.type), cont(term.body)); 
    case "App":
      const nfunc = cont(term.func);
      if (nfunc[c] === "Lam") {
        return cont(subst(nfunc.body, term.argm, 0), env);
      } else {
        return App(cont(nfunc), cont(term.argm));
      }
    case "Ref": return Ref(term.name);
    case "MVar": return MVar(term.name, term.args.map(cont));
    default: throw "Norm:\nUnexpected constructor to normalize:"+term[c];
  }
}
function whnf(term, env) { return norm(term, env, rec = (x)=>x ); }
function   nf(term, env) { return norm(term, env, rec = norm   ); }


// Substitution
function subst(term, val, depth=0) {
  switch (term[c]) {
    case "Var":
      return depth === term.index ? val : Var(term.index - (term.index > depth ? 1 : 0));
    case "Typ":
      return Typ();
    case "All":
      const dom = subst(term.dom, val, depth);
      const cod = subst(term.cod, val && shift(val), depth+1);
      return All(term.name, dom, cod);
    case "Lam":
      const type = term.type && subst(term.type, val, depth);
      const body =              subst(term.body, val && shift(val), depth+1);
      return Lam(term.name, type, body);
    case "App":
      const func = subst(term.func, val, depth);
      const argm = subst(term.argm, val, depth);
      return App(func, argm);
    case "Ref":
      return Ref(term.name);
  }
}

// Infers the type of a term
function infer(term, env, ctx = Ctx()) {
  switch (term[c]) {
    case "Knd": throw "Infer:\nCannot infer the type of Kind !";
    case "Typ": return Knd();
    case "All":
      const dom = infer(term.dom, env, ctx);
      const cod = infer(term.cod, env, extend(ctx, [term.name, term.dom]));
      if (!are_convertible(dom, Typ(), env)) {
        throw "Infer:\nDomain of forall is not a type: `" + show(term, ctx) + "`.\n\n[CONTEXT]\n" + show_context(ctx);
      }
      if (!are_convertible(cod, Typ(), env) && !are_convertible(cod, Knd(), env)) {
        throw "Infer:\nCodomain of forall is neither a type nor a kind: `" + show(term, ctx) + "`.\n\n[CONTEXT]\n" + show_context(ctx);
      }
      return cod;
    case "Lam":
      if (term.type === null) {
        throw "Infer:\nCan't infer non-annotated lambda `"+show(term,ctx)+"`.\n\n[CONTEXT]\n" + show_context(ctx);
      } else {
        const body_t = infer(term.body, env, extend(ctx, [term.name, term.type]));
        const term_t = All(term.name, term.type, body_t);
        infer(term_t, env, ctx);
        return term_t;
      }
    case "App":
      const func_t = whnf(infer(term.func, env, ctx), env);
      if (func_t[c] !== "All") {
        throw "Infer:\nNon-function application on `" + show(term, ctx) + "`.\n\n[CONTEXT]\n" + show_context(ctx);
      }
      const dom_t = subst(func_t.dom, term.argm);
      const argm_v = check(term.argm, dom_t, env, ctx, () => "`" + show(term, ctx) + "`'s argument");
      return subst(func_t.cod, argm_v);
    case "Ref":
      return do_get(env,term.name).type;
    case "Var":
      return get_term(ctx, term.index);
  }
}

// Checks if a term has given type
function check(term, type, env, ctx = Ctx(), expr) {
  var expr = expr || (() => show(term, ctx));
  var type = whnf(type, env);
  if (type[c] === "All" && term[c] === "Lam" && !term.type) {
    infer(type, env, ctx);
    const ex_ctx = extend(ctx, [type.name, type.dom]);
    const body_v = check(term.body, type.cod, env, ex_ctx, () => "`" + show(term, ctx) + "`'s body");
    return Lam(type.name, type.dom, body_v);
  } else {
    const term_t = infer(term, env, ctx);
    let checks = false;
    try {
      checks = are_convertible(type, term_t, env);
    } catch (e) {
      console.log("Couldn't decide if terms are equal.");
      console.log(e);
    }
    if (!checks) {
      throw "Check:"                               +"\n"+
        "Type mismatch on " + expr() + "."         +"\n"+
        "- Expect = " + show(  nf(type  ,env), ctx)+"\n"+
        "- Actual = " + show(whnf(term_t,env), ctx)+"\n"+
        "[CONTEXT]"                                +"\n"+
        show_context(ctx);
    }
    return term;
  }
}


function add_env_rule(env, qualname, rule) { get(env,qualname).rules.push(rule); }

function check_rule(env, lhs, rhs) {
  // TODO
}

function process_instruction(instruction, env) {
  let ins = scope(instruction,env);
  switch (ins[c]) {
  case "Decl":
    add_new_symbol(env,ins.name,ins.type);
    log_ok("Symbol declared",ins.name+" with type " +show(ins.type) );
    break;
  case "Def":
    log_ok("Symbol defined",
      (ins.name || 'unnamed')+
      " with type " + (ins.type ? show(ins.type) : 'undefined')+
      " and definition "+(ins.def ? show(ins.def) : 'undefined'));
    break;
  case "Rew":
      check_rule(env,ins.lhs,ins.rhs);
      log_ok("Rewrite rule added",show(ins.lhs)+ " --\> " + show(ins.rhs));
    break;
  case "Req":
    break;
  case "Eval":
    log_info("Eval",show(nf(ins.term)));
    
    break;
  case "Infer":
    log_info("Infer",show(infer(ins.term,env)));
    break;
  case "Check":
    check(ins.term,ins.type,env);
    log_ok("Check",show(ins.term)+" has indeed type "+show(ins.type));
    break;
  case "Print":
    log_info("Show",show(ins.term));
    break;
  default:
    throw "Instruction:\nUnexepected instruction type:"+ins[c];
  }
}

var env;

// Main processing loop
var code, instructions;
function process_all_instructions() {
  clear_logs();
  try {
    // Parsing of raw text code
    code = document.getElementById("code").value;
    instructions = parse( code );
    log_ok("Parsing","done.");
    // Reseting the environnement
    env = Env();
    instructions.forEach((ins)=>process_instruction(ins,env));
    log_ok("All done !","");
  } catch(e) { log_err(e); throw e; }
}

</script>